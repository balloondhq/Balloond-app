// Prisma schema for Balloon'd Dating App Phase 2 with Subscriptions & Moderation

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model with location and subscription support
model User {
  id              String    @id @default(uuid())
  email           String    @unique
  password        String?   // Null for OAuth users
  provider        AuthProvider @default(LOCAL)
  providerId      String?   // OAuth provider user ID
  
  // Profile information
  name            String
  bio             String?
  age             Int?
  photos          String[]  // Array of photo URLs
  prompts         Json?     // Structured prompts and answers
  
  // Location data with PostGIS
  location        Json?     // Store as {lat, lng} for PostGIS queries
  latitude        Float?
  longitude       Float?
  radius          Int       @default(50) // Search radius in km
  lastLocationUpdate DateTime?
  
  // Matching preferences
  minAge          Int       @default(18)
  maxAge          Int       @default(99)
  
  // Account status & Verification
  isActive        Boolean   @default(true)
  isVerified      Boolean   @default(false)
  verificationStatus VerificationStatus @default(UNVERIFIED)
  verificationPhoto String?  // Selfie for verification
  verificationAttempts Int   @default(0)
  lastVerificationAttempt DateTime?
  lastSeen        DateTime  @default(now())
  
  // Subscription & Premium Features
  subscriptionTier SubscriptionTier @default(FREE)
  subscriptionId  String?   // Stripe/IAP subscription ID
  subscriptionEndDate DateTime?
  dailyBoosts     Int       @default(0)
  superPopsRemaining Int    @default(0)
  
  // Moderation flags
  isReported      Boolean   @default(false)
  isBanned        Boolean   @default(false)
  bannedUntil     DateTime?
  moderationNotes String?
  
  // Relations
  sentPops        Pop[]     @relation("SentPops")
  receivedPops    Pop[]     @relation("ReceivedPops")
  matches         Match[]   @relation("UserMatches")
  matchedWith     Match[]   @relation("MatchedWithUser")
  sentMessages    Message[] @relation("SentMessages")
  chats           ChatParticipant[]
  subscription    Subscription?
  sentReports     Report[]  @relation("ReportedBy")
  receivedReports Report[]  @relation("ReportedUser")
  blockedUsers    Block[]   @relation("Blocker")
  blockedBy       Block[]   @relation("Blocked")
  payments        Payment[]
  pushTokens      PushToken[]
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([email])
  @@index([latitude, longitude])
  @@index([subscriptionTier])
}

// Subscription model for managing premium features
model Subscription {
  id              String    @id @default(uuid())
  userId          String    @unique
  tier            SubscriptionTier
  stripeSubscriptionId String? // Stripe subscription ID
  appleReceiptData String?    // Apple IAP receipt
  googlePurchaseToken String? // Google Play purchase token
  status          SubscriptionStatus @default(ACTIVE)
  currentPeriodStart DateTime
  currentPeriodEnd DateTime
  cancelAtPeriodEnd Boolean @default(false)
  
  // Features based on tier
  dailyPops       Int       // Daily balloon limit
  canSeeWhoLiked  Boolean   @default(false)
  hasBoosts       Boolean   @default(false)
  hasSuperPops    Boolean   @default(false)
  hasAdvancedFilters Boolean @default(false)
  hasThemedBalloons Boolean @default(false)
  
  user            User      @relation(fields: [userId], references: [id])
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([status])
}

// Payment history
model Payment {
  id              String    @id @default(uuid())
  userId          String
  amount          Float
  currency        String    @default("USD")
  paymentMethod   PaymentMethod
  stripePaymentIntentId String?
  appleTransactionId String?
  googleOrderId   String?
  status          PaymentStatus
  description     String?
  
  user            User      @relation(fields: [userId], references: [id])
  
  createdAt       DateTime  @default(now())
  
  @@index([userId])
  @@index([status])
}

// Pop interaction model with premium features
model Pop {
  id            String    @id @default(uuid())
  userId        String    // User who popped
  targetUserId  String    // User whose balloon was popped
  popType       PopType   @default(SINGLE)
  isSuperPop    Boolean   @default(false) // Premium feature
  revealed      Boolean   @default(false)
  balloonTheme  String?   // Premium themed balloons
  
  user          User      @relation("SentPops", fields: [userId], references: [id])
  targetUser    User      @relation("ReceivedPops", fields: [targetUserId], references: [id])
  
  createdAt     DateTime  @default(now())
  
  @@unique([userId, targetUserId])
  @@index([userId])
  @@index([targetUserId])
}

// Match model (when both users double pop)
model Match {
  id            String    @id @default(uuid())
  userId        String
  matchedUserId String
  isActive      Boolean   @default(true)
  
  user          User      @relation("UserMatches", fields: [userId], references: [id])
  matchedUser   User      @relation("MatchedWithUser", fields: [matchedUserId], references: [id])
  chat          Chat?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@unique([userId, matchedUserId])
  @@index([userId])
  @@index([matchedUserId])
}

// Chat model
model Chat {
  id            String    @id @default(uuid())
  matchId       String    @unique
  lastMessageAt DateTime?
  isBlocked     Boolean   @default(false)
  
  match         Match     @relation(fields: [matchId], references: [id])
  messages      Message[]
  participants  ChatParticipant[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([matchId])
}

// Chat participant model
model ChatParticipant {
  id            String    @id @default(uuid())
  chatId        String
  userId        String
  lastRead      DateTime  @default(now())
  isTyping      Boolean   @default(false)
  notificationsEnabled Boolean @default(true)
  
  chat          Chat      @relation(fields: [chatId], references: [id])
  user          User      @relation(fields: [userId], references: [id])
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@unique([chatId, userId])
  @@index([chatId])
  @@index([userId])
}

// Message model with voice support
model Message {
  id            String    @id @default(uuid())
  chatId        String
  senderId      String
  content       String?   @db.Text // Null for voice/media messages
  messageType   MessageType @default(TEXT)
  mediaUrl      String?   // URL for voice/image/video
  mediaDuration Int?      // Duration in seconds for voice/video
  isRead        Boolean   @default(false)
  isDeleted     Boolean   @default(false)
  
  chat          Chat      @relation(fields: [chatId], references: [id])
  sender        User      @relation("SentMessages", fields: [senderId], references: [id])
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([chatId])
  @@index([senderId])
}

// Report system for moderation
model Report {
  id            String    @id @default(uuid())
  reporterId    String
  reportedUserId String
  reportType    ReportType
  reason        String
  description   String?   @db.Text
  evidence      String[]  // URLs to screenshots/evidence
  status        ReportStatus @default(PENDING)
  moderatorNotes String?  @db.Text
  resolvedAt    DateTime?
  resolvedBy    String?   // Admin user ID
  
  reporter      User      @relation("ReportedBy", fields: [reporterId], references: [id])
  reportedUser  User      @relation("ReportedUser", fields: [reportedUserId], references: [id])
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([reporterId])
  @@index([reportedUserId])
  @@index([status])
}

// Block system
model Block {
  id            String    @id @default(uuid())
  blockerId     String
  blockedUserId String
  reason        String?
  
  blocker       User      @relation("Blocker", fields: [blockerId], references: [id])
  blockedUser   User      @relation("Blocked", fields: [blockedUserId], references: [id])
  
  createdAt     DateTime  @default(now())
  
  @@unique([blockerId, blockedUserId])
  @@index([blockerId])
  @@index([blockedUserId])
}

// Photo moderation
model PhotoModeration {
  id            String    @id @default(uuid())
  userId        String
  photoUrl      String
  aiScore       Float?    // AI confidence score (0-1)
  aiResult      ModerationResult?
  isApproved    Boolean?
  moderatorNotes String?
  moderatedBy   String?   // Admin user ID
  
  createdAt     DateTime  @default(now())
  moderatedAt   DateTime?
  
  @@index([userId])
  @@index([isApproved])
  @@index([aiResult])
}

// Push notification tokens
model PushToken {
  id            String    @id @default(uuid())
  userId        String
  token         String    @unique
  platform      Platform
  isActive      Boolean   @default(true)
  
  user          User      @relation(fields: [userId], references: [id])
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([userId])
  @@index([token])
}

// Daily balloon allocation tracking
model BalloonAllocation {
  id            String    @id @default(uuid())
  userId        String
  date          DateTime  @db.Date
  balloonsUsed  Int       @default(0)
  maxBalloons   Int       // Based on subscription tier
  boostsUsed    Int       @default(0)
  superPopsUsed Int       @default(0)
  
  createdAt     DateTime  @default(now())
  
  @@unique([userId, date])
  @@index([userId])
  @@index([date])
}

// Enums
enum AuthProvider {
  LOCAL
  GOOGLE
  APPLE
}

enum PopType {
  SINGLE  // Preview (blurred photo)
  DOUBLE  // Full reveal
  SUPER   // Premium super pop
}

enum MessageType {
  TEXT
  IMAGE
  VOICE
  VIDEO
  GIF
}

enum SubscriptionTier {
  FREE
  GOLD
  GLOWING
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
  TRIALING
}

enum PaymentMethod {
  STRIPE
  APPLE_IAP
  GOOGLE_PLAY
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ReportType {
  FAKE_PROFILE
  INAPPROPRIATE_CONTENT
  HARASSMENT
  SPAM
  UNDERAGE
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}

enum ModerationResult {
  SAFE
  NUDITY
  VIOLENCE
  EXPLICIT
  REVIEW_NEEDED
}

enum VerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

enum Platform {
  IOS
  ANDROID
  WEB
}
